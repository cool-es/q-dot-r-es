            ////// MODES //////

qr symbols contain a bitstream which is not aligned to its constituent 8-bit codewords (pg. 20)

assuming byte / alphanumeric / numeric mode, version 1 (pg. 24),
the bitstream consists of:
• mode indicator, 4 bits (0100 / 0010 / 0001)
• character count indicator (8 / 9 / 10)
• data bit stream
• terminator: 0000

byte mode is shift-jis (pg. 29), which i believe is ascii-adjacent

alphanumeric mode supports 45 different characters:
numbers (hex 30 - 39)
alphabet (41 - 5A)
[ space, $, %, *, +, -, ., /, : ] (20, 24, 25, 2B, 2D - 2F, 3A)

reference on data modes: pg. 22, mixing data modes: pg. 92

numeric mode has an avg size of (10*i+1)/3 bits for i digits

number of bits in char count indicator - pg. 24
    [10,  9,  8,  8] 1..=9
    [12, 11, 16, 10] 10..=26
    [14, 13, 16, 12] 27..=40
     Nu  AN  By  Kj

            ////// BITS AND CODEWORDS //////

codewords are aligned in columns of width 2,
are always read right-to-left in rows either up or down,
and all data has its MSB first (pg. 53)

symbol structure refs: pg. 13 (layout), pg. 21 (version size / codeword capacity table),
pg. 34 (error correction / data capacity table),

error correction refs: pg. 41

generator polynomials: pg. 73

symbol encoding example: pg. 90

remainder bits per version (pg. 21):
2..=6       7 bits
14..=20     3 bits
21..=27     4 bits
28..=34     3 bits
all other versions 0 bits

            ////// OTHER PATTERNS //////

symbol size is 21 + 4 * (version -1) for version between 1 and 40

position detection patterns are 7*7 modules, but are also framed by a line of white modules, so in effect they're 8*8

alignment patterns (small squares in versions > 1) are 5*5 modules, are offset 4 modules in on every side (4 modules fit between the size and the alignment pattern), three are missing, in each of the position detection patterns' corners. coordinates are in a table on pg. 88

version : n where n^2-3 is no. of alignment patterns:
1    : (no pattern)
2..  : 2
7..  : 3
14.. : 4 
21.. : 5
28.. : 6
35.. : 7

timing patterns (dotted lines) are at x = 6, y = 6

version info data blocks: pgs. 60 (graphical layout of bits), 84 (example of encryption)

data (i'm assuming after padding it out to the fill the alotted data space) is divided into blocks, each block individually error-corrected, divided into codewords, and then interleaved. the shorter blocks come first. a code with this block division:
[d1 d2 e1] [d3 d4 e2] [d5 d6 d7 e3] [d8 d9 d10 e4]
would be regarded as:
[d1 d2     e1]
[d3 d4     e2]
[d5 d6 d7  e3]
[d8 d9 d10 e4]
and the final codeword sequence would be:
d1 d3 d5 d8, d2 d4 d6 d9, d7 d10, e1 e2 e3 e4

to do this i need to:
convert bit sequence back to a list of bytes
divide the list into multiple smaller lists
error-correct each list individually
do more list-dividing, or use some clever math, to get a new single list of bytes
convert that list into bit sequence
write
