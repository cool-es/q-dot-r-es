• mode overhead calculation for when to switch modes
    finish optimize_mode()
• remainder bits
    this might not be necessary since it works implicitly
    (though might be good to add explicit bounds checking)
• check to see if arbitrary data is possible (emoji, etc)
• clean up code (remove the allow(dead_code))
• add stats printing (version, bit count, etc)
• write unchecked functions (hidden from the user) that don't excessively check their inputs
    offenders:
        callers of bad_version()
        callers of out_of_bounds()
        xy_to_index()
• add comments and documentation so it's readable to others
• improve efficiency of "choose best mask" function
• restructure code to be divided into logical sections:
    data conversion
        badstream type + operations
    error correction
        polynomial type
        galois field
        reed-solomon
    graphics
        bitmap type + operations

maybe:
• penalty routine still mysterious - do more troubleshooting
    idk if i need to, it's kind of a technicality whether it works right or not

going through the standards doc:
• data modes, mode switching (pg. 22)
    mostly done!! great job me!! kanji and ECI remain
• bitstream optimization  (pg. 92)

~~~~~~~~~~~~

example stats output i want:

Encoding input "hello123hello" at error correction level H
Message compression 13% (104 bits -> 94 bits)
Version 3 chosen (width 29 px):
| Message    | Padding    | Error correction    |
| 12 bytes   | 4 bytes    | 10 bytes            |
Mask 4 chosen (97% of avg. penalty)
Saving as out.xbm
