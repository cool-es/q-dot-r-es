â€¢ work on bitstream.rs, replicate the function of first_qr_code()
â€¢ data entry ðŸ¥³ tables!! ðŸŽŠ ... specifically:
    - remainder bits (see notes, pg 21)
    - data codewords as function of version / error correction (pg. 34)
    - error correction characteristics (pg. 41)
â€¢ penalty routine still mysterious - do more troubleshooting
â€¢ update penalty functions to not use get_row()
â€¢ mode overhead calculation for when to switch modes
â€¢ fix this: data ending in the last codeword is corrupted


â€¢ mode edge cases:
    renders but unreadable:
        (1, "3."),(0, "1415926535897"),(2, "e"),(2, "e"),(2, "e") version 1L, 146 bits
        (1, "22"),(0, "11111111111111"),(2, "e"),(0, "0"),(1, "E") version 1L, 146 bits 
        (0,"1234567890123456"),(1,"12345678901") version 1L, 146 bits 
        (1,"1234567890123456789"),(1,"12") version 1L, 146 bits 
    good working codes, to compare against:
        (2, "this is ascii >w<") version 1L, 152 bits (max length)
        (1, "3."),(0, "141592653589"),(2, "e"),(2, "e"),(2, "e") version 1L, 138 bits
        (1, "11"),(0, "11111111111"),(2, "1"),(2, "1"),(2, "1")
        (0, n(3).as_str()),(0, n(33).as_str()) 148+t.

going through the standards doc:
â€¢ data modes, mode switching (pg. 22)
    mostly done!! great job me!! kanji and ECI remain
â€¢ codeword blocks (pg. 52, refer pg. 54)
â€¢ symbol encoding example (pg. 90)
â€¢ bitstream optimization  (pg. 92)

PITEOG stuff:
â€¢ deprecate the continuous-data "Img" type?
â€¢ update get_row() to handle sizes >128 (versions 28 and onward)
    idk if this is necessary